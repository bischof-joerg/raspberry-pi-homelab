api:
  enabled: true
  address: 0.0.0.0:8686
  playground: false

sources:
  docker:
    type: docker_logs
    docker_host: unix:///var/run/docker.sock
    include_labels:
      # Only ingest logs from the "homelab-home-prod-mon" stack.
      - com.docker.compose.project=homelab-home-prod-mon
  host_journald:
    type: journald

transforms:
  # Filter journald down to just the desired systemd units.
  filter_journald_units:
    type: remap
    inputs: ["host_journald"]
    source: |
      allowed = [
        "docker.service",
        "containerd.service",
        "ufw.service",
        "ssh.service",
        "sshd.service",
        "systemd-udevd.service",
      ]

      if !exists(._SYSTEMD_UNIT) {
        abort
      }

      unit = to_string(._SYSTEMD_UNIT) ?? ""
      if unit == "" || !includes(allowed, unit) {
        abort
      }

  normalize:
    type: remap
    inputs: ["docker", "filter_journald_units"]
    # yamllint disable rule:line-length
    source: |
      # 1. Message & Timestamp
      # Message field for VictoriaLogs (_msg_field=message)
      .message = to_string(.message) ?? to_string(.log) ?? to_string(.MESSAGE) ?? ""

      # Drop known benign cAdvisor noise on Raspberry Pi (no PC/BIOS DMI)
      # This part was already in your normalize block
      if contains(.message, "Error while reading product_name: open /sys/class/dmi/id/product_name") {
        abort
      }

      # Timestamp field for VictoriaLogs (_time_field=timestamp)
      .ts = null
      if exists(.timestamp) {
        .ts = parse_timestamp(to_string(.timestamp) ?? "", "%+") ?? null
      }
      if is_null(.ts) && exists(._SOURCE_REALTIME_TIMESTAMP) {
        us = to_int(to_string(._SOURCE_REALTIME_TIMESTAMP) ?? "") ?? null
        if !is_null(us) {
          .ts = from_unix_timestamp(us, unit: "microseconds") ?? null
        }
      }
      if is_null(.ts) {
        .timestamp = now()
      } else {
        .timestamp = .ts
      }
      del(.ts)

      # 2. Host & Container
      .host = get_env_var("HOST_NODE_NAME") ?? get_env_var("HOSTNAME") ?? "unknown"
      .container_name = to_string(.container_name) ?? to_string(.docker.container_name) ?? to_string(._SYSTEMD_UNIT) ?? to_string(.SYSLOG_IDENTIFIER) ?? "unknown"

      # 3. Stack & Service Labels
      .stack = to_string(.label."com.docker.compose.project") ?? to_string(.labels."com.docker.compose.project") ?? "homelab-home-prod"
      .service = to_string(.label."com.docker.compose.service") ?? to_string(.labels."com.docker.compose.service") ?? .container_name

      .namespace = "prod"

      # 3b. Postdeploy e2e markers (logfmt): extract token/seq into dedicated fields.
      # Use a more relaxed match (contains instead of starts with ^)
      # to account for potential prefixing.
      if match(.message, r'event=vector_e2e\b') {
        # Ensure stable service label
        .service = "vector-e2e"

        # Try to parse logfmt from the message
        # We parse it into a temporary variable 'e2e'
        e2e, err = parse_logfmt(.message)
        if err == null {
          # Use 'string' and 'int' casts safely
          .e2e_token = to_string(e2e.token) ?? null
          .e2e_seq = to_int(e2e.seq) ?? null
        }
      }

      # 4. Basic level normalization
      tmp = downcase(to_string(.level) ?? "")
      if tmp != "" {
        .level = tmp
      } else {
        m = downcase(.message)
        if match(m, r'\berror\b') {
          .level = "error"
        } else if match(m, r'\bwarn(ing)?\b') {
          .level = "warn"
        } else if match(m, r'\bdebug\b') {
          .level = "debug"
        } else {
          .level = "info"
        }
      }

      # 5. Keep original unit, if present
      if exists(._SYSTEMD_UNIT) {
        .systemd_unit = to_string(._SYSTEMD_UNIT) ?? null
      }
      # Drop very noisy docker/containerd lifecycle chatter (triggered by short-lived containers).
      if exists(.systemd_unit) && .level == "info" {
        if .systemd_unit == "docker.service" && contains(.message, "msg=\"ignoring event\"") {
          abort
        }
        if .systemd_unit == "containerd.service" && contains(.message, "cleaning up") {
          abort
        }
      }
      # Prune raw journald metadata (keep derived fields like systemd_unit, host, level, namespace, stack, service).
      ks = keys(.)
      for_each(ks) -> |_i, k| {
        if match(k, r'^__') || match(k, r'^_') {
          . = remove!(value: ., path: [k])
        }
      }

      # Drop common redundant journald fields (non-fatal if missing).
      . = remove(value: ., path: ["PRIORITY"]) ?? .
      . = remove(value: ., path: ["SYSLOG_FACILITY"]) ?? .
      . = remove(value: ., path: ["SYSLOG_IDENTIFIER"]) ?? .


      # 6. Cleanup
      del(.label)
      del(.labels)
      del(.docker)
      del(.container)
      del(.image)
      del(.container_id)
      del(.container_created_at)
      del(.source_type)
      del(.stream)

  # drop cadvisor noise about missing DMI info on Raspberry Pi (no PC/BIOS DMI)
  # establish chain: normalize -> drop_cadvisor_sysinfo_noise -> vlogs
  drop_cadvisor_sysinfo_noise:
    type: filter
    inputs: ["normalize"] # Input must be the normalized stream
    condition:
      type: vrl
      source: |
        msg = to_string(.message) ?? ""
        # The filter condition: returns 'false' for logs that should be dropped
        !( .service == "cadvisor" && ( contains(msg, "Found node without any CPU") || contains(msg, "Found node without cache information")))

sinks:
  vlogs:
    type: http
    inputs: ["drop_cadvisor_sysinfo_noise"] # Correct end of the chain
    uri: "http://victorialogs:9428/insert/jsonline?_stream_fields=host,stack,service,namespace,container_name&_msg_field=message&_time_field=timestamp"
    compression: gzip
    encoding:
      codec: json
    framing:
      method: newline_delimited
    healthcheck:
      enabled: true
    buffer:
      type: memory
      max_events: 10000
      when_full: drop_newest
